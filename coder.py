import os
import sys
import argparse
import subprocess
from github import Github
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.messages import HumanMessage, SystemMessage

# --- ДОБАВЛЕНО ---
from dotenv import load_dotenv

# Загружаем переменные из .env (если файл есть)
# Это нужно для локального запуска на Windows.
# В GitHub Actions этого файла не будет, но там переменные и так есть в системе.
load_dotenv() 
# -----------------

# Настройки
REPO_NAME = os.getenv("GITHUB_REPOSITORY")  # Автоматически берется в Actions
GITHUB_TOKEN = os.getenv("GH_PAT") or os.getenv("GITHUB_TOKEN")
API_KEY = os.getenv("GOOGLE_API_KEY")

def setup_git_user():
    """Настраиваем git user для коммитов от имени бота"""
    subprocess.run(["git", "config", "--global", "user.name", "AI Agent"], check=True)
    subprocess.run(["git", "config", "--global", "user.email", "agent@ai.com"], check=True)

def get_file_structure():
    """Собираем структуру проекта, чтобы агент понимал контекст"""
    files_list = []
    for root, dirs, files in os.walk("."):
        if ".git" in dirs:
            dirs.remove(".git")
        if ".github" in dirs:
            dirs.remove(".github")
        for file in files:
            if file.endswith((".py", ".md", ".txt", ".yml", ".yaml")):
                path = os.path.join(root, file)
                files_list.append(path)
    return "\n".join(files_list)

def parse_llm_response(response_text):
    """Парсим ответ LLM, ищем теги <FILE path="...">... content ...</FILE>"""
    import re
    files = []
    # Регулярка ищет контент между тегами
    pattern = re.compile(r'<FILE path="(.*?)">\n(.*?)\n</FILE>', re.DOTALL)
    matches = pattern.findall(response_text)
    
    for path, content in matches:
        files.append({"path": path, "content": content})
    return files

def main(issue_number):
    if not API_KEY:
        print("Error: GOOGLE_API_KEY is missing")
        sys.exit(1)

    print(f"--- Processing Issue #{issue_number} ---")
    
    # 1. Подключаемся к GitHub
    g = Github(GITHUB_TOKEN)
    repo = g.get_repo(REPO_NAME)
    issue = repo.get_issue(number=int(issue_number))
    
    print(f"Task: {issue.title}")
    
    # 2. Инициализируем Gemini
    llm = ChatGoogleGenerativeAI(
        model="gemini-2.0-flash",
        google_api_key=API_KEY,
        temperature=0.1
    )

    # 3. Готовим промпт
    files_context = get_file_structure()
    
    system_prompt = """Ты - опытный Python-разработчик. Твоя задача - выполнить задание из Issue.
    Ты должен вернуть полный код измененных или новых файлов.
    
    ФОРМАТ ОТВЕТА (Строго соблюдай!):
    Для каждого файла используй XML-подобные теги:
    <FILE path="имя_файла.py">
    код файла целиком
    </FILE>
    
    Если нужно изменить файл, верни ЕГО ПОЛНОСТЬЮ с изменениями.
    Не пиши никаких объяснений до или после кода. Только блоки <FILE>."""
    
    user_prompt = f"""
    ЗАДАЧА: {issue.title}
    ОПИСАНИЕ: {issue.body}
    
    ТЕКУЩИЕ ФАЙЛЫ В ПРОЕКТЕ:
    {files_context}
    """

    # 4. Запрос к LLM
    print("Asking Gemini...")
    messages = [
        SystemMessage(content=system_prompt),
        HumanMessage(content=user_prompt)
    ]
    response = llm.invoke(messages)
    generated_files = parse_llm_response(response.content)
    
    if not generated_files:
        print("No files generated by LLM. Raw response:")
        print(response.content)
        sys.exit(1)

    # 5. Применяем изменения локально
    setup_git_user()
    branch_name = f"feature/issue-{issue_number}"
    
    # Создаем ветку
    try:
        subprocess.run(["git", "checkout", "-b", branch_name], check=True)
    except subprocess.CalledProcessError:
        subprocess.run(["git", "checkout", branch_name], check=True)

    for file_data in generated_files:
        path = file_data["path"]
        content = file_data["content"]
        
        # Создаем директории если нужно
        os.makedirs(os.path.dirname(path) if os.path.dirname(path) else ".", exist_ok=True)
        
        with open(path, "w", encoding="utf-8") as f:
            f.write(content)
        print(f"Updated/Created: {path}")

    # 6. Коммит и Пуш
    subprocess.run(["git", "add", "."], check=True)
    subprocess.run(["git", "commit", "-m", f"Fix: {issue.title}"], check=True)
    subprocess.run(["git", "push", "origin", branch_name], check=True)
    
    # 7. Создаем Pull Request
    try:
        pr = repo.create_pull(
            title=f"Resolve: {issue.title}",
            body=f"Generated by AI Agent for Issue #{issue_number}",
            head=branch_name,
            base="main"
        )
        print(f"PR Created: {pr.html_url}")
    except Exception as e:
        print(f"PR creation failed (maybe exists?): {e}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--issue", required=True, help="Issue number")
    args = parser.parse_args()
    main(args.issue)
